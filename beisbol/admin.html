<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Administrador — Torneo Béisbol 2 Grupos + Semifinales</title>
  <style>
    /* ESTILOS EXISTENTES... */
    
    /* Nuevo estilo para grupo de 3 equipos */
    .groupC {background:rgba(34,197,94,.12);border:1px solid rgba(34,197,94,.45)}
  </style>
</head>
<body>
  <header>
    <div class="container">
      <h1>Administrador — Torneo Béisbol 2 Grupos + Semifinales</h1>
      <div class="subtitle">Crea y gestiona tu torneo de béisbol. <strong>Grupo A: 3 equipos | Grupo B: 4 equipos</strong></div>
    </div>
  </header>

  <main class="container grid">
    <section class="card">
      <h2>1) Equipos por grupo</h2>
      <div class="groups">
        <div><label>Grupo A (3 equipos)</label><textarea id="ga">Tigres
Leones
Águilas</textarea></div>
        <div><label>Grupo B (4 equipos)</label><textarea id="gb">Osos
Toros
Lobos
Panteras</textarea></div>
      </div>

      <!-- Resto del código igual hasta el script -->
    </section>
  </main>

<script>
// ===== CONFIGURACIÓN =====
const STORAGE_KEY = 'torneo_beisbol_v2_grupo3y4';
const $ = (selector, root = document) => root.querySelector(selector);

// ===== ESTADO INICIAL =====
let state = {
  groups: {
    A: { teams: ['Tigres', 'Leones', 'Águilas'], matches: [] },
    B: { teams: ['Osos', 'Toros', 'Lobos', 'Panteras'], matches: [] }
  },
  points: { win: 2, draw: 1, loss: 0 },
  knockout: {
    sf1: { home: '', away: '', gh: null, ga: null, winner: '', hour: '', place: '' },
    sf2: { home: '', away: '', gh: null, ga: null, winner: '', hour: '', place: '' },
    final: { home: '', away: '', gh: null, ga: null, winner: '', hour: '', place: '' },
    third: { home: '', away: '', gh: null, ga: null, winner: '', hour: '', place: '' }
  },
  tournamentName: '',
  theme: { color: '#0284c7', bg: '#f8fafc' }
};

// ===== HELPERS =====
function parseTeams(txt) {
  return String(txt || '').split('\n').map(s => s.trim()).filter(Boolean);
}

// NUEVO: Calendario para grupo de 3 equipos (todos contra todos)
function roundRobin3(teams) {
  if (teams.length !== 3) return [];
  return [
    [teams[0], teams[1]],
    [teams[0], teams[2]],
    [teams[1], teams[2]]
  ];
}

// Calendario para grupo de 4 equipos (existente)
function roundRobin4(teams) {
  if (teams.length !== 4) return [];
  return [
    [teams[0], teams[1]],
    [teams[2], teams[3]],
    [teams[0], teams[2]],
    [teams[1], teams[3]],
    [teams[0], teams[3]],
    [teams[1], teams[2]]
  ];
}

function valInt(v) {
  if (v === '' || v == null) return null;
  const n = parseInt(v, 10);
  return Number.isFinite(n) && n >= 0 ? n : null;
}

function computeTable(matches, teams) {
  const table = Object.fromEntries(teams.map(team => [team, {
    team, 
    JJ: 0,  // Juegos Jugados
    G: 0,   // Ganados
    P: 0,   // Perdidos
    E: 0,   // Empatados
    PCT: 0, // Porcentaje de Victorias
    JV: 0,  // Juegos de Ventaja
    RA: 0,  // Carreras Anotadas
    RC: 0,  // Carreras Concedidas
    DIF: 0, // Diferencia
    Pts: 0  // Puntos
  }]));
  
  const cfg = state.points;
  
  matches.forEach(match => {
    if (match.gh == null || match.ga == null) return;
    
    const homeTeam = table[match.home];
    const awayTeam = table[match.away];
    if (!homeTeam || !awayTeam) return;
    
    // Actualizar partidos jugados
    homeTeam.JJ++;
    awayTeam.JJ++;
    
    // Actualizar carreras
    homeTeam.RA += match.gh;
    homeTeam.RC += match.ga;
    awayTeam.RA += match.ga;
    awayTeam.RC += match.gh;
    
    // Determinar resultado
    if (match.gh > match.ga) {
      homeTeam.G++;
      awayTeam.P++;
      homeTeam.Pts += cfg.win;
      awayTeam.Pts += cfg.loss;
    } else if (match.gh < match.ga) {
      awayTeam.G++;
      homeTeam.P++;
      awayTeam.Pts += cfg.win;
      homeTeam.Pts += cfg.loss;
    } else {
      homeTeam.E++;
      awayTeam.E++;
      homeTeam.Pts += cfg.draw;
      awayTeam.Pts += cfg.draw;
    }
  });
  
  // Calcular diferencia de carreras
  teams.forEach(team => {
    table[team].DIF = table[team].RA - table[team].RC;
  });
  
  // Calcular porcentaje de victorias
  teams.forEach(team => {
    table[team].PCT = table[team].JJ > 0 ? (table[team].G / table[team].JJ) : 0;
  });
  
  // Ordenar por criterios de desempate
  const sorted = Object.values(table).sort((a, b) => {
    // 1. Puntos
    if (b.Pts !== a.Pts) return b.Pts - a.Pts;
    // 2. Porcentaje de victorias
    if (b.PCT !== a.PCT) return b.PCT - a.PCT;
    // 3. Diferencia de carreras
    if (b.DIF !== a.DIF) return b.DIF - a.DIF;
    // 4. Carreras a favor
    if (b.RA !== a.RA) return b.RA - a.RA;
    // 5. Enfrentamiento directo
    const directMatch = matches.find(m => 
      (m.home === a.team && m.away === b.team) || 
      (m.home === b.team && m.away === a.team)
    );
    if (directMatch && directMatch.gh != null && directMatch.ga != null) {
      if (directMatch.home === a.team && directMatch.gh > directMatch.ga) return -1;
      if (directMatch.home === b.team && directMatch.gh < directMatch.ga) return -1;
      if (directMatch.home === a.team && directMatch.gh < directMatch.ga) return 1;
      if (directMatch.home === b.team && directMatch.gh > directMatch.ga) return 1;
    }
    // 6. Alfabético como último recurso
    return a.team.localeCompare(b.team);
  });
  
  // Calcular Juegos de Ventaja después de ordenar
  if (sorted.length > 0) {
    const leader = sorted[0];
    sorted.forEach(team => {
      team.JV = ((leader.G - team.G) + (team.P - leader.P)) / 2;
    });
  }
  
  return sorted;
}

function groupWinner(groupKey) {
  const group = state.groups[groupKey];
  const rows = computeTable(group.matches, group.teams);
  return rows[0]?.team || '';
}

function groupRunnerUp(groupKey) {
  const group = state.groups[groupKey];
  const rows = computeTable(group.matches, group.teams);
  return rows[1]?.team || '';
}

// ===== RENDER GRUPOS =====
function renderGroups() {
  const root = $('#groupsRoot');
  root.innerHTML = '';
  
  ['A', 'B'].forEach(groupKey => {
    const group = state.groups[groupKey];
    const teams = group.teams || [];
    
    const groupDiv = document.createElement('div');
    groupDiv.className = `groupBox group${groupKey}`;
    groupDiv.innerHTML = `<h3>Grupo ${groupKey} (${teams.length} equipos)</h3>`;
    
    const matchesContainer = document.createElement('div');
    matchesContainer.className = 'matches';
    
    // Crear partidos según el tamaño del grupo
    let calendar;
    if (teams.length === 3) {
      calendar = roundRobin3(teams);
    } else if (teams.length === 4) {
      calendar = roundRobin4(teams);
    } else {
      calendar = [];
    }
    
    calendar.forEach(([home, away]) => {
      const existingMatch = group.matches.find(m => m.home === home && m.away === away) || 
                          { home, away, gh: null, ga: null, hour: '', place: '' };
      
      const matchDiv = document.createElement('div');
      matchDiv.className = 'match';
      matchDiv.innerHTML = `
        <div class="team">${home}</div>
        <div class="team" style="justify-content:center">
          <input type="number" min="0" class="score-home" data-group="${groupKey}" data-home="${home}" data-away="${away}" 
                 value="${existingMatch.gh == null ? '' : existingMatch.gh}" style="max-width:80px">
          <span class="dash">—</span>
          <input type="number" min="0" class="score-away" data-group="${groupKey}" data-home="${home}" data-away="${away}" 
                 value="${existingMatch.ga == null ? '' : existingMatch.ga}" style="max-width:80px">
        </div>
        <div class="team" style="justify-content:flex-end">${away}</div>
      `;
      
      const infoDiv = document.createElement('div');
      infoDiv.className = 'info';
      infoDiv.innerHTML = `
        <input type="text" class="match-hour" data-group="${groupKey}" data-home="${home}" data-away="${away}" 
               placeholder="Hora (ej. 14:00)" value="${existingMatch.hour || ''}">
        <input type="text" class="match-place" data-group="${groupKey}" data-home="${home}" data-away="${away}" 
               placeholder="Lugar (ej. Estadio)" value="${existingMatch.place || ''}">
      `;
      
      matchesContainer.appendChild(matchDiv);
      matchesContainer.appendChild(infoDiv);
    });
    
    groupDiv.appendChild(matchesContainer);
    
    // Tabla de posiciones
    const rows = computeTable(group.matches, teams);
    const tableHTML = `
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>#</th>
              <th>Equipo</th>
              <th>JJ</th>
              <th>G</th>
              <th>P</th>
              <th>%G</th>
              <th><span class="tooltip">JV</span></th>
              <th>RA</th>
              <th>RC</th>
              <th>DIF</th>
              <th>Pts</th>
            </tr>
          </thead>
          <tbody>
            ${rows.map((row, index) => `
              <tr class="${index === 0 ? 'first' : index === 1 ? 'second' : ''}">
                <td class="pos">${index + 1}</td>
                <td><strong>${row.team}</strong></td>
                <td>${row.JJ}</td>
                <td>${row.G}</td>
                <td>${row.P}</td>
                <td class="pct">${row.PCT.toFixed(3)}</td>
                <td>${row.JV === 0 ? '-' : row.JV.toFixed(1)}</td>
                <td>${row.RA}</td>
                <td>${row.RC}</td>
                <td>${row.DIF > 0 ? '+' : ''}${row.DIF}</td>
                <td class="pts">${row.Pts}</td>
              </tr>
            `).join('')}
          </tbody>
        </table>
      </div>
      <div class="note">
        <strong>Clasificación:</strong> 
        <span style="background:rgba(34,197,94,.15); padding:2px 6px; border-radius:4px;">1º</span> Semifinales, 
        <span style="background:rgba(251,191,36,.15); padding:2px 6px; border-radius:4px;">2º</span> Semifinales
      </div>
    `;
    
    groupDiv.insertAdjacentHTML('beforeend', tableHTML);
    root.appendChild(groupDiv);
  });
  
  setupGroupEventListeners();
}

// Resto del código JavaScript se mantiene igual...
// [Las funciones setupGroupEventListeners, updateKnockout, saveState, loadState, etc. se mantienen igual]

// ===== INICIALIZACIÓN =====
function init() {
  loadState();
  applyStateToUI();
  renderGroups();
  updateKnockout();
  
  // Generar rol
  $('#btnGenerate').addEventListener('click', function() {
    state.groups.A.teams = parseTeams($('#ga').value);
    state.groups.B.teams = parseTeams($('#gb').value);
    state.groups.A.matches = [];
    state.groups.B.matches = [];
    saveState();
    renderGroups();
    updateKnockout();
  });
  
  // Resto de los event listeners se mantienen igual...
}

// Iniciar
document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>